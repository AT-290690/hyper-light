<style>
  body {
    background: black;
  }
</style>
<body>
  <div id="canvas-container"></div>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.10/two.min.js"
    integrity="sha512-D9pUm3+gWPkv/Wl6vd45vRLjdkdEKGje7BxOxYG0N6m4UlEUB7RSljBwpmJNAOuf6txLLtlaRchoKfzngr/bQg=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <script>
    const canvasContainer = document.getElementById('canvas-container')
  </script>
  <script>
    const VOID = null
    const _tco =
      func =>
      (...args) => {
        let result = func(...args)
        while (typeof result === 'function') {
          result = result()
        }
        return result
      }
    const _pipe =
      (...fns) =>
      x =>
        fns.reduce((v, f) => f(v), x)
    const _spread = items =>
      Array.isArray(items[0])
        ? items.reduce((acc, item) => [...acc, ...item], [])
        : items.reduce((acc, item) => ({ ...acc, ...item }), {})
    const protolessModule = methods => {
      const env = Object.create(null)
      for (const method in methods) env[method] = methods[method]
      return env
    }
  </script>
  <script>
    const LIBRARY = {
      ['SKETCH']: {
        ['background']: (color = 'var(--background-primary)') =>
          (LIBRARY.SKETCH.CANVAS_CONTAINER.firstChild.style.background = color),
        ['makescene']: (width = 100, height = 100, callback) => {
          LIBRARY.SKETCH.engine?.removeEventListener('update')
          LIBRARY.SKETCH.CANVAS_CONTAINER =
            document.getElementById('canvas-container')
          LIBRARY.SKETCH.engine = new Two({
            width,
            height,
          }).appendTo(LIBRARY.SKETCH.CANVAS_CONTAINER)
          callback()
          return 'Scene created!'
        },
        ['makeline']: (x1, y1, x2, y2, color = 'white') => {
          const line = LIBRARY.SKETCH.engine.makeLine(x1, y1, x2, y2)
          line.stroke = color
          return line
        },
        ['update']: (...args) => {
          LIBRARY.SKETCH.engine.update(...args)
          return 'Updated!'
        },
        ['width']: (ratio = 1) => LIBRARY.SKETCH.engine.width * ratio,
        ['height']: (ratio = 1) => LIBRARY.SKETCH.engine.height * ratio,
      },
      ['MATH']: {
        ['sin']: n => Math.sin(n),
        ['cos']: n => Math.cos(n),
        ['PI']: 3.141592653589793,
      },
    }
  </script>
  <script>
    ;(() => {
      var MATH,
        SKETCH,
        background,
        makescene,
        makeline,
        update,
        width,
        height,
        sin,
        cos,
        PI,
        WIDTH,
        HEIGHT
      ;(() => {
        MATH = LIBRARY['MATH']
        SKETCH = LIBRARY['SKETCH']
        background = SKETCH['background']
        makescene = SKETCH['makescene']
        makeline = SKETCH['makeline']
        update = SKETCH['update']
        width = SKETCH['width']
        height = SKETCH['height']
        sin = MATH['sin']
        cos = MATH['cos']
        PI = MATH['PI']
        return makescene(
          void (WIDTH = 500) || WIDTH,
          void (HEIGHT = 500) || HEIGHT,
          () => {
            var theta,
              step,
              angle,
              length,
              level,
              maxlevel,
              x,
              y,
              xstack,
              ystack,
              drawbranch
            return (() => {
              background('#010')
              void (theta = 0.8) || theta
              void (step = 0.7) || step
              void (angle = PI * 0.5) || angle
              void (length = height(0.25)) || length
              void (level = 0) || level
              void (maxlevel = 10) || maxlevel
              void (x = width(0.5)) || x
              void (y = height(1)) || y
              void (xstack = [maxlevel]) || xstack
              void (ystack = [maxlevel]) || ystack
              void (drawbranch = dir => {
                var deltax, deltay, nextx, nexty
                return (() => {
                  void (deltax = length * cos(angle)) || deltax
                  void (deltay = length * sin(angle)) || deltay
                  void (nextx = x + deltax) || nextx
                  void (nexty = y - deltay) || nexty
                  makeline(x, y, nextx, nexty)
                  void (xstack[level] = x) || xstack
                  void (ystack[level] = y) || ystack
                  void (x = nextx) || x
                  void (y = nexty) || y
                  void (level = level + 1) || level
                  void (angle = angle + theta * dir) || angle
                  void (length = length * step) || length
                  level < maxlevel
                    ? (() => {
                        drawbranch(1)
                        return drawbranch(-1)
                      })()
                    : null
                  void (angle = angle - theta * dir) || angle
                  void (length = length / step) || length
                  void (level = level - 1) || level
                  void (x = xstack[level]) || x
                  return void (y = ystack[level]) || y
                })()
              }) || drawbranch
              drawbranch(0)
              return update()
            })()
          }
        )
      })()
    })()
  </script>
</body>
